#pragma once
#include <vector>
#include <unordered_map>
#include <unordered_set>
#include <numeric>
#include <random>
#include <iostream>

class Graph
{
	using nodeListTy = std::vector<int>;
	using setTy = std::unordered_map<int, nodeListTy>;
	using adjSetTy = std::unordered_set<int>;

	struct nodeInfo 
	{
		// each vertex in adjSet indicates the 2nd vertex of the edge
		// i ---- j   means graph[i].adjSet contains j
		adjSetTy adjSet; 

		// original idx
		int originalName;

		nodeInfo(int originalIdx) : originalName(originalIdx) {};
	};

public:
	Graph ();
	Graph (int nodeNum);

	Graph (const Graph&) = delete;
	Graph (Graph&&) = default;

	Graph& operator=(const Graph&) = delete;
	Graph& operator=(Graph&&) = default;

	~Graph() = default;

	// reserve numNodes space for the graph 
	// resize the inverseOrder vector
	void reserve(int numNodes);

	// add a new edge btw n1 and n2 
	// if one of the nodes is not present, it will be inserted
	void addEdge(int n1, int n2);

	// add multiple edges at the same nodes
	// this should be used only with nodes in the internal representation
	void addFillInEdges(int _n, nodeListTy others);

	// counts the number of edges to be added 
	int countFillInEdges(int _n, nodeListTy others);

	// create a random undirected and connected graph
	// number of nodes = numNodes
	// edges are generated by sampling a number p from a uniform distribution btw 0-1
	// if p is less than q than the edges is added
	// q defines the density of the graph
	void randomPopulate(int numNodes, float q);

	// compute the monotonely adjacent set for each node
	// return a map containing all the info
	setTy computeMonAdjSet() const;

	// compute the monotonely adjacent set for the specified node n
	nodeListTy computeMonAdjSet(int n) const;

	void setOrder(nodeListTy order);

	void reset();

	// print the graph with the original vertices names
	void printGraph() const;

	// ------------------------------------------------------------------------------------ 

	int getNodeNumber() const;

	int getEdgeNumber() const;

	// get the internal node list
	nodeListTy getNodeList() const;

	// get the vertex based on the order (this is a) 
	int getVertex(int orderIdx) const;

	// get the order based on the vertex (this is a^-1) 
	int getOrder(int vertex) const;

	// get entire order list 
	nodeListTy getOrder() const;

	// get entire order list but with original names
	nodeListTy getOriginalOrder() const;

	// get the adjacent list of node n
	nodeListTy getAdjSet(int n) const;

private: 
	// the index of the vector is the node number
	using graphTy = std::vector<nodeInfo>;

	int nextNodeNum; 
	int numEdges;
	// actual graph
	graphTy graph;
	// mapping btw internal node reprentation and user defined nodes
	std::unordered_map<int, int> nodeMapping;
	// alpha
	nodeListTy order;
	// alpha^-1
	nodeListTy inverseOrder;

	// ------------------ private methods ------------------
	
	float uniformProb();

	// add edge btw node in the internal representation
	void _addEdge(int _n1, int _n2);
};

